(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{419:function(v,_,t){"use strict";t.r(_);var a=t(56),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),t("p",[v._v("垃圾回收重点在堆上进行")]),v._v(" "),t("ul",[t("li",[v._v("频繁的回收年轻代")]),v._v(" "),t("li",[v._v("较少回收老年代")]),v._v(" "),t("li",[v._v("基本不懂永久代（元空间）")])]),v._v(" "),t("h2",{attrs:{id:"垃圾检测算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾检测算法"}},[v._v("#")]),v._v(" 垃圾检测算法")]),v._v(" "),t("p",[v._v("判断一个对象是否存活主要有两种算法：引用计数算法和可达性分析算法")]),v._v(" "),t("h3",{attrs:{id:"引用计数算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[v._v("#")]),v._v(" 引用计数算法")]),v._v(" "),t("p",[v._v("原理：每个对象保存一个整形的引用计数属性，当该对象被引用时加1，当引用失效时减1，当为0时表示不再被引用，可以被回收。")]),v._v(" "),t("ul",[t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("实现简单，垃圾对象便于识别")]),v._v(" "),t("li",[v._v("判定效率高，回收没有延时")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("需要单独的字段存储引用，增加内存消耗")]),v._v(" "),t("li",[v._v("需要进行加减运算，增加负担")]),v._v(" "),t("li",[v._v("最重要的是无法解决循环引用的问题")])])])]),v._v(" "),t("h3",{attrs:{id:"可达性分析算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[v._v("#")]),v._v(" 可达性分析算法")]),v._v(" "),t("p",[v._v("可达性分析算法同样具有实现简单、效率高的特点，而且还能解决循环引用的问题。该算法需要一个GC Roots作为根，java采用此种算法。"),t("br"),v._v("\n基本思路：")]),v._v(" "),t("ol",[t("li",[v._v("以跟对象（GC Roots）为起始点，从上至下搜索被跟对象连接的对象是否可达")]),v._v(" "),t("li",[v._v("使用该算法走过的路径称为引用链")]),v._v(" "),t("li",[v._v("如果对象没有任何引用链连接则是不可达的，可以被回收，只有被跟对象直接或间接链接的对象才是存货对象")])]),v._v(" "),t("h2",{attrs:{id:"gc-roots"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc-roots"}},[v._v("#")]),v._v(" GC Roots")]),v._v(" "),t("p",[v._v("GC Roots包含以下对象：")]),v._v(" "),t("ul",[t("li",[v._v("虚拟机栈中引用的对象")]),v._v(" "),t("li",[v._v("本地方法栈JNI引用的对象")]),v._v(" "),t("li",[v._v("方法区中静态属性引用的对象")]),v._v(" "),t("li",[v._v("方法区中常量引用的对象")]),v._v(" "),t("li",[v._v("所有被同步锁持有的对象")]),v._v(" "),t("li",[v._v("虚拟机内部持有的对象")]),v._v(" "),t("li",[v._v("反映虚拟机内部情况的对象，如JMXBean等")])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("技巧")]),v._v(" "),t("p",[v._v("如果一个指针，指向一个保存在堆中的对象，但是它自身不保存在堆中，那么它就是一个root。")])]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("p",[v._v("如果使用可达性分析算法判断一个对象是否存活，则要保证分析工作是在一个一致性快照中进行，因此在GC时必须Stop The World")])]),v._v(" "),t("h2",{attrs:{id:"finalization机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finalization机制"}},[v._v("#")]),v._v(" finalization机制")]),v._v(" "),t("p",[v._v("对象在被回收前总会调用finalize()方法，在此方法中释放资源等操作。不要主动调用该方法，因为此方法会导致对象复活。"),t("br"),v._v("\n有了finalization机制，对象则有三个状态：")]),v._v(" "),t("ol",[t("li",[v._v("可达状态")]),v._v(" "),t("li",[v._v("可被复活状态")]),v._v(" "),t("li",[v._v("不可达状态")])]),v._v(" "),t("h2",{attrs:{id:"垃圾清除算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾清除算法"}},[v._v("#")]),v._v(" 垃圾清除算法")]),v._v(" "),t("p",[v._v("当成功分离出可达对象和不可达对象，GC接下来的任务就是执行垃圾清除任务，释放掉无用的内存。目前常见的算法有：标记-清除算法、复制算法、标记-压缩算法。")]),v._v(" "),t("h3",{attrs:{id:"标记-清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除"}},[v._v("#")]),v._v(" 标记-清除")]),v._v(" "),t("p",[v._v("执行过程：")]),v._v(" "),t("ul",[t("li",[v._v("标记：从GC Roots开始分析不可达对象")]),v._v(" "),t("li",[v._v("清除：对堆内存从头开始进行线性搜索，如果对象没有被标位可达对象，内存就会被回收")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("效率不高")]),v._v(" "),t("li",[v._v("空闲内存分散")]),v._v(" "),t("li",[v._v("GC需要暂停整个应用")])]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("p",[v._v("内存清除是指记录该内存地址，需要使用时将对象存入该地址指向的内存。")])]),v._v(" "),t("h3",{attrs:{id:"复制算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[v._v("#")]),v._v(" 复制算法")]),v._v(" "),t("p",[v._v("将内存空间分为两份，每次只使用其中一份。在GC时，将正在使用的内存中存活的对象复制到另外一份内存中，然后清除本内存所有对象，交换两份内存身份。"),t("br"),v._v("\n优点：")]),v._v(" "),t("ul",[t("li",[v._v("不会出现内存碎片")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("需要两倍空间")]),v._v(" "),t("li",[v._v("对于G1这种拆分大量region的GC，复制而不是移动意味着需要维系各个region之间的引用关系，这个开销也不小")])]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("特别的")]),v._v(" "),t("p",[v._v("如果内存中垃圾对象特别多，复制算法需要复制的对象并不多，比如Young区的Survivor0和Survivor1。")])]),v._v(" "),t("h3",{attrs:{id:"标记-压缩算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记-压缩算法"}},[v._v("#")]),v._v(" 标记-压缩算法")]),v._v(" "),t("p",[v._v("标记-压缩算法也可叫做标记-清除-压缩算法，它是对标记-清除算法的扩展。会将分散的对象移动到一起，使内存对齐。"),t("br"),v._v("\n优点：")]),v._v(" "),t("ul",[t("li",[v._v("消除了标记-清除算法对象分散的缺点")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("效率不高，低于复制算法")]),v._v(" "),t("li",[v._v("移动对象时，如果对象被其他对象引用则还要调整引用的地址")]),v._v(" "),t("li",[v._v("移动过程中需要STW")])])])}),[],!1,null,null,null);_.default=s.exports}}]);