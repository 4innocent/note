# 方法区

## 介绍
方法区和堆一样是各个线程共享的区域，方法区的大小决定了jvm能够加载多少个类，方法区可以设置为固定大小和可扩展大小习惯上把方法区成为永久代（java7及以前）或元空间。永久代和元空间最大的区别是<span style="color:red">元空间不再使用jvm设置的堆内存，而是使用本地内存</span>，相比以前不容易发生OOM。
::: tip 设置元空间大小参数
-XX:MetaspaceSize：设置初始值
-XX:MaxMetaspaceSize：设置最大值，默认-1即使用所有可用物理内存
:::
### 内存泄漏和内存溢出
- 内存泄漏：堆中含有不被引用但仍然存活的对象
- 内存溢出：堆内存被耗尽，无法创建新对象
## 方法区存储内容
方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译的代码缓存等。<span>java8类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量依然保存在堆中</span>
### 类型信息
对于每个加载的类型（Class、enum、interface、annotation），jvm必须保存以下信息：
- 这个类型的完整有效名称（全路径包名加类型名）
- 这个类型的父类的完整有效名称
- 这个类型的修饰符
- 这个类型直接接口的一个有序列表
### 域(Field)信息
- jvm必须在方法区保存类型的所有域的相关信息以及域的声明顺序
- 域的具体信息（修饰符，类型，名称）
### 方法(Method)信息
方法区必须保存方法的相关信息以及方法的声明顺序，具体信息包括：
- 方法名称
- 方法修饰符
- 方法的返回值类型
- 方法的参数数量及类型
- 方法的字节码、操作数栈信息、局部变量表以及大小（abstract和native除外）
- 异常表（abstract和native除外）
  - 异常表包括异常的起始位置、终止位置、代码处理在程序计数器中的偏移值、对应异常类的常量池索引
### non-final的类变量
- 类变量随着类加载而加载，它们成为类数据在逻辑上的一部分
- 类变量被所有实例共享，即使没有实例也可以访问它
### final全局常量
被声明为final的类变量在类编译时就被分配了
## 运行时常量池
运行时常量池是方法区的一部分，常量池表是class文件的一部分，存放编译期生成的的各种字面量和符号引用，这些内容在类文件加载后会存放在运行时常量池中，常量池表保存的信息有：数量值、字符串值、类引用、方法引用、字段引用。  
jvm为每个加载的类型都维护一个常量池，通过索引进行访问，运行时常量池相比于常量池表具有动态性

hotspot对常量池的回收策略是只要常量不再被引用就可以被回收（但不是一定会被回收）
