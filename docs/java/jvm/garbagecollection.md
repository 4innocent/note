# 垃圾回收
垃圾回收重点在堆上进行
- 频繁的回收年轻代
- 较少回收老年代
- 基本不懂永久代（元空间）
## 垃圾检测算法
判断一个对象是否存活主要有两种算法：引用计数算法和可达性分析算法
### 引用计数算法
原理：每个对象保存一个整形的引用计数属性，当该对象被引用时加1，当引用失效时减1，当为0时表示不再被引用，可以被回收。
- 优点：
  - 实现简单，垃圾对象便于识别
  - 判定效率高，回收没有延时
- 缺点：
  - 需要单独的字段存储引用，增加内存消耗
  - 需要进行加减运算，增加负担
  - 最重要的是无法解决循环引用的问题
### 可达性分析算法
可达性分析算法同样具有实现简单、效率高的特点，而且还能解决循环引用的问题。该算法需要一个GC Roots作为根，java采用此种算法。  
基本思路：
1. 以跟对象（GC Roots）为起始点，从上至下搜索被跟对象连接的对象是否可达
2. 使用该算法走过的路径称为引用链
3. 如果对象没有任何引用链连接则是不可达的，可以被回收，只有被跟对象直接或间接链接的对象才是存货对象
## GC Roots
GC Roots包含以下对象：
- 虚拟机栈中引用的对象
- 本地方法栈JNI引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- 虚拟机内部持有的对象
- 反映虚拟机内部情况的对象，如JMXBean等
::: tip 技巧
如果一个指针，指向一个保存在堆中的对象，但是它自身不保存在堆中，那么它就是一个root。
:::
::: warning 注意
如果使用可达性分析算法判断一个对象是否存活，则要保证分析工作是在一个一致性快照中进行，因此在GC时必须Stop The World
:::
## finalization机制
对象在被回收前总会调用finalize()方法，在此方法中释放资源等操作。不要主动调用该方法，因为此方法会导致对象复活。  
有了finalization机制，对象则有三个状态：
1. 可达状态
2. 可被复活状态
3. 不可达状态
## 垃圾清除算法
当成功分离出可达对象和不可达对象，GC接下来的任务就是执行垃圾清除任务，释放掉无用的内存。目前常见的算法有：标记-清除算法、复制算法、标记-压缩算法。
### 标记-清除
执行过程：
- 标记：从GC Roots开始分析不可达对象
- 清除：对堆内存从头开始进行线性搜索，如果对象没有被标位可达对象，内存就会被回收

缺点：
- 效率不高
- 空闲内存分散
- GC需要暂停整个应用
::: warning 注意
内存清除是指记录该内存地址，需要使用时将对象存入该地址指向的内存。
:::
### 复制算法
将内存空间分为两份，每次只使用其中一份。在GC时，将正在使用的内存中存活的对象复制到另外一份内存中，然后清除本内存所有对象，交换两份内存身份。  
优点：
- 不会出现内存碎片

缺点：  
- 需要两倍空间
- 对于G1这种拆分大量region的GC，复制而不是移动意味着需要维系各个region之间的引用关系，这个开销也不小
::: warning 特别的
如果内存中垃圾对象特别多，复制算法需要复制的对象并不多，比如Young区的Survivor0和Survivor1。
:::
### 标记-压缩算法
标记-压缩算法也可叫做标记-清除-压缩算法，它是对标记-清除算法的扩展。会将分散的对象移动到一起，使内存对齐。  
优点：
- 消除了标记-清除算法对象分散的缺点

缺点：
- 效率不高，低于复制算法
- 移动对象时，如果对象被其他对象引用则还要调整引用的地址
- 移动过程中需要STW