# 虚拟机栈

## 栈指令和寄存器指令
jvm中的指令集是基于栈实现的，它具有指令集小、容易实现以及最重要的跨平台的优点，缺点是速度慢，相同功能需要更多地指令；基于寄存器的指令集效率较高，但是寄存器是依赖硬件的，因此不能跨平台，汇编语言就是典型的基于寄存器的指令集  
计算1+1的简单比较
``` 
iconst_1
iconst_1 // 连续将两个常量1压入栈
iadd     // 遇到加法指令弹出两个数据执行加法运算
istore_0 // 将计算结果压入栈中
```

```
mov exa,1 // 想exa寄存器中存入1
add exa,1 // 对寄存器做加一操作
```

## jvm的栈
栈用来保存程序正常运行，堆用来保存运行时的数据，这是两者最大的区别。  
程序由一个个方法组成，每个方法执行依靠对栈的入栈、出栈操作完成，方法执行完成返回下一条指令的地址。

在jvm中可以通过-Xss选项设置线程的最大栈空间，栈的大小直接决定方法调用的最大深度，对应的其实是操作数栈。
## 栈的存储单位
- 每个线程都有自己的线程栈，栈中的数据都是以栈帧（stack frame）形式存在
- 在线程中执行的每个方法对应一个栈桢
- 栈桢是一个内存块，其中保存着方法运行的各种数据
- jvm对线程栈的操作只有入栈和出栈，操作的基本对象就是栈桢
- 针对一个活动的线程来说，同一时间只有一个活跃的栈桢，称为为当前栈桢，对应的方法称为为当前方法，定义这个方法的类即为当前类
- 在方法中又调用其他方法，则会创建新的栈桢压入栈顶

## 栈桢
java方法有两种返回函数的方式，一种是方法正常执行结束，另外一种是遇到异常。两种方式都会将当前栈桢弹出，并将结果返回给前一条栈桢，并使其成为当前栈桢。
### 栈桢内容
栈帧中存放着：
- <span style="color:red">局部变量表</span>
- <span style="color:red">操作数栈</span>
- 动态链接
- 方法返回地址
- 一些附加信息
#### 局部变量表
局部变量表也被称为局部变量数组或本地变量表。
- 定义一个数字数组用于存储方法参数和定义在方法内部的局部变量
- 局部变量表对应线程栈中栈桢，属于线程的私有数据，因此不存在安全问题
- 局部变量表的大小是编译期确定下来的，并且存放在maximum local variables数据项中，运行期间不会改变
- 参数值的存放总是从index0开始，基本的存储单元为slot（槽），可以存储编译期可知的8种基本类型、引用类型、returnAddress类型
- 32位以内的变量占用一个槽，64位的变量占用两个，（byte、short、char、boolean）在存储前会被转换为int、int、float、returnAddress占用一个槽、long和double占用两个槽
- jvm会为每个slot分配一个访问索引，访问64位的数据只需访问第一个slot索引即可，如果当前栈桢是由构造方法或实例方法创建，则this永远在index0处，然后才是方法参数和局部变量
- 不同于类变量（类变量有两次赋值机会，准备阶段赋值为默认值，初始化阶段赋值为程序定义值），局部变量一旦创建必须在使用前赋值
- 局部变量表中的变量也是垃圾回收时的一个根节点
局部变量表中的slot能够被复用，一旦一个局部变量超过了它的作用域，那么在其后声明的局部变量则很有可能复用这个slot，例如
``` java
public static void slotTest(){
    {
        int a = 0;
        System.out.pringln(a);
    }
    int b = 1; // 此时的b变量会复用a的slot
}
```
#### 操作数栈
栈桢中除了局部变量表外还有一个重要的结构就是操作数栈，也可以称为表达式栈。操作数栈根据字节码指令进行入栈和出栈。
- 操作数栈主要用来保存计算结果和计算的中间变量
- 当一个方法开始执行时，会创建一个栈桢，此时的操作数栈为空
- 32位数据占用一个栈深度，64位数据占用两个栈深度
- 操作数栈的最大深度在编译期就已经确定了，并保存在class文件中
- 如果被调用的方法有返回值，其返回值（returnAddress）会被压入当前栈桢的操作数栈中，并更新pc寄存器中下一条需要执行的指令
可以使用`javap -v`类名.class来反编译class文件，查看具体执行内容

#### 动态链接
- 每一个栈桢内部都保存一个指向运行时常量池中该栈桢所属方法的引用
- 在描述一个方法调用了另一个方法时，就是使用常量池中指向方法的符号引用表示的，动态链接的作用就是将这些符号引用转变为直接引用

#### 方法返回地址
存放调用该方法的指令地址，以便方法调用结束返回原位置执行。方法执行完毕会更新pc寄存器为改地址。
方法调用结束有两种方式：正常执行完成、发生异常
- 正常执行完成会返回执行结果，该结果存放在局部变量表中
- 在方法执行过程中遇到异常，并且这个异常没有在该方法内部处理，也就是在本方法的异常表中没有找到对应的异常处理器，那么就会导致方法退出。异常退出方法不会有任何返回值。